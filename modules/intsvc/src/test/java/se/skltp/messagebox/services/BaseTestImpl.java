package se.skltp.messagebox.services;

import java.lang.reflect.Field;
import java.util.Date;
import javax.servlet.http.HttpServletRequest;
import javax.xml.ws.WebServiceContext;
import javax.xml.ws.handler.MessageContext;

import org.junit.Before;
import org.mockito.Mock;
import se.riv.itintegration.messagebox.v1.MessageStatusType;
import se.skltp.messagebox.core.entity.Message;
import se.skltp.messagebox.core.service.MessageService;
import se.skltp.messagebox.core.service.TimeService;

import static org.mockito.Mockito.when;

/**
 * Base class for testing.
 *
 * Note: TimeService will by default be mocked-up to return a constant time.
 *
 * @author mats.olsson@callistaenterprise.se
 */
public class BaseTestImpl {
    @Mock
    MessageService messageService;
    @Mock
    WebServiceContext wsContext;
    @Mock
    MessageContext msgContext;
    @Mock
    HttpServletRequest servletRequest;
    @Mock
    TimeService timeService;

    @Before()
    public void onSetUp() {
        // setup the timeservice to run in fixed time
        long now = System.currentTimeMillis();
        when(timeService.now()).thenReturn(now);
        when(timeService.date()).thenReturn(new Date(now));
    }

    // needed to set the message id which is normally generated by the persistance layer
    public Message createMessage(long id, String receiverId, String targetOrganization, String serviceContract, String body) throws NoSuchFieldException, IllegalAccessException {
        Message result = new Message("sourceId", receiverId, targetOrganization, serviceContract, body, MessageStatusType.RECEIVED, timeService.date(), "correlationId");
        Field field = result.getClass().getDeclaredField("id");
        field.setAccessible(true);
        field.set(result, id);
        return result;
    }
}
